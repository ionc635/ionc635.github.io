---
layout: single
title: TIL DAY 38
---
# 자료구조 Tree, Graph

## [오늘의 교훈]

- 어제는 승철이와 늦게까지 대화를 나누느라 늦게 잠을 청했고, 잠에 들고자 노력했으나 고민과 걱정으로 한참을 뒤척이다가 잠에 들었다. 하지만 예상외로 아침 일찍 잠에서 깼다. 다시 잠을 청해도 잠에 들 수가 없었다. 걱정이 나를 각성 상태로 만들어준듯 했다. 당장 책상에 앉으라는 신호로 받아들여 컴퓨터를 켜고 코플릿에 접속했다. 어제 본 문제를 다시 풀어보는데, 신기하게도 너무 이해가 잘됐다. 어제까지만 해도 어렵게 느껴졌던 것이 하루 아침에 이해된 것이다. 꾸준히만 한다면 시간이 해결해 줄 것이라는 믿음이 생겼다.
- 오후에는 어제의 페어와 함께 페어 프로그래밍을 진행했다. 자료 구조를 구현하는 문제였는데, 중간중간 이해되지 않는 부분이 등장했다. 그럴 때면 항상 페어 분께 이런 부분이 이해가 되지 않는다고 말했고, 함께 고민해 나가면서 해결해 나갔다. 우리나라 사람들의 특징 중 하나는 바로 질문을 하지 않는 것이라고 한다. 생각해보면 나도 그런 스타일에 속했던 것 같다. 코드스테이츠를 하면서 바뀌고 있는 것이 느껴지고 있다.

## [오늘의 해결]

- 이번 페어분께서는 코드를 굉장히 깔끔하게 작성했다. 레퍼런스 코드와 거의 상이했다. 코드를 잘 짜는 것이 이렇게 멋있게 보일 수가 없다. 내가 앞으로 멋있어 보이기 위한 몇 가지 코드를 정리해보고자 한다.

```jsx
// 구조 분해 할당을 활용한 반복문

edges.forEach((edge) => {
  const [row, col, direction] = edge; 
    if (direction === "undirected") {
      result[col][row] = 1;
    }
    result[row][col] = 1;
});
```

```jsx
// matrix 구조 만들기

new Array(max + 1).fill(0).map((row) => new Array(max + 1).fill(0));

[
[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]
]
```

- `!!` 연산자는 undefined나 null 값이 나올 때, 보다 확실하게 boolean 값을 나타내기 위해 사용한다.
- 고차함수를 능숙하게 사용할 수 있다면 문제 해결 능력이 향상될 것이다.(연습)
- 노드 안에는 데이터만 존재하는 것이 아니라 객체 형태로 되어 있다. { value: x, children: [{b}, {c}]}
- vertax를 추가/삭제하는 문제는 matrix가 아닌 list를 형태를 사용해야 한다. matrix는 배열의 길이가 변화되기 때문.
- dfs는 보통 Stack, 재귀를 사용하고, bfs는 Queue와 while 반복문을 사용한다

## [오늘의 한줄]

- 너무 걱정하지 말자. 꾸준히 한다면 시간이 해결해준다.
