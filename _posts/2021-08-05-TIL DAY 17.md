---
layout: single
title: TIL DAY 17
---
# 2021-08-05-TIL DAY 17

## Spread/Rest 문법

### **Achievement Goals**

- Spread/Rest 문법, 구조 분해 할당을 사용할 수 있다.

### **[Spread 문법](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax)**

- 주로 배열을 풀어서 인자로 전달하거나, 배열을 풀어서 각각의 요소로 넣을 때에 사용한다.

```jsx
function sum(x, y, z) {
  return x + y + z;
}

const numbers = [1, 2, 3];

sum(...numbers) // 6
```

### **[Rest 문법](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters)**

- 파라미터를 배열의 형태로 받아서 사용할 수 있다. 파라미터 개수가 가변적일 때 유용하다.

```jsx
function sum(...theArgs) {
  return theArgs.reduce((previous, current) => {
    return previous + current;
  });
}

sum(1,2,3) // 6
sum(1,2,3,4) // 10
```

### 배열/객체에서 활용

```jsx
// 배열 합치기

let parts = ['shoulders', 'knees'];
let lyrics = ['head', ...parts, 'and', 'toes']; 
// ["head", "shoulders", "knees", "and", "toes"]

let arr1 = [0, 1, 2];
let arr2 = [3, 4, 5];
arr1 = [...arr1, ...arr2]; // [0, 1, 2, 3, 4, 5]
// spread 문법은 기존 배열을 변경하지 않으므로 immutable하다. 
```

```jsx
// 배열 복사

let arr = [1, 2, 3];
let arr2 = [...arr]; // arr.slice() 와 유사
arr2.push(4);

// arr = [1, 2, 3]
// arr2 = [1, 2, 3, 4]
```

```jsx
// 객체에서 활용

let obj1 = { foo: 'bar', x: 42 };
let obj2 = { foo: 'baz', y: 13 };

let clonedObj = { ...obj1 };
let mergedObj = { ...obj1, ...obj2 };

// clonedObj = {foo: "bar", x: 42}
// mergedObj = {foo: "baz", x: 42, y: 13}
```

```jsx
// 함수에서 나머지 파라미터 받아오기

function myFun(a, b, ...manyMoreArgs) {
  console.log("a", a);
  console.log("b", b);
  console.log("manyMoreArgs", manyMoreArgs);
}

myFun("one", "two", "three", "four", "five", "six");

// a one
// b two
// manyMoreArgs ["three", "four", "five", "six"]
```

## [구조 분해(Destructing)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

- 구조 분해 할당은 Spread 문법을 이용하여 값을 해체한 후, 개별 값을 변수에 새로 할당하는 과정을 말한다.

```jsx
// 배열
const [a, b, ...rest] = [10, 20, 30, 40, 50];
// a = 10, b = 20, rest = [30, 40, 50]

// 객체
const {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40};
// a = 10, b = 20, rest = {c: 30, d: 40}
```

- 객체에서 구조 분해 할당을 사용하는 경우, 선언(const, let, var)과 함께 사용하지 않으면 에러가 발생할 수 있다.

```jsx
// 중첩된 객체 및 배열의 구조 분해

var metadata = {
    title: "Scratchpad",
    translations: [
       {
        locale: "de",
        localization_tags: [ ],
        last_edit: "2014-04-14T08:43:37",
        url: "/de/docs/Tools/Scratchpad",
        title: "JavaScript-Umgebung"
       }
    ],
    url: "/en-US/docs/Tools/Scratchpad"
};

var { title: englishTitle, translations: [{ title: localeTitle }] } = metadata;

console.log(englishTitle); // "Scratchpad"
console.log(localeTitle);  // "JavaScript-Umgebung"
```

## JavaScript Koans

- 금일 코드스테이츠에서 JavaScript 문법과 관련된 문제 50개를 페어 프로그래밍을 통해 풀어보았다. 조금 헷갈리거나 이해가 되지 않는 부분을 따로 복습하기 위해 정리해둔다.

- 04_Scope.js

```jsx
// 함수 선언식(declaration)과 함수 표현식(expression)의 차이

expect(typeof funcDeclared).to.equal(FILL_ME_IN); // 'function'
expect(typeof funcExpressed).to.equal(FILL_ME_IN); // 'string'
  
function funcDeclared() {
  return 'this is a function declaration';
}

funcExpressed = function () {
  return 'this is a function expression';
};
```

```jsx
// lexical scope와 closure에 대해 다시 확인

let age = 27;
let name = 'jin';
let height = 179;

function outerFn() {
  let age = 24;
  name = 'jimin';
  let height = 178;

  function innerFn() {
    age = 26;
    let name = 'suga';
    return height;
  }

  innerFn();

  expect(age).to.equal(26);
  expect(name).to.equal('jimin');

  return innerFn;
}

const innerFn = outerFn();

expect(age).to.equal(27);
expect(name).to.equal('jimin');
expect(innerFn()).to.equal(178);
```

- 06_Types-part2.js

```jsx
const obj = {};
expect(Object.keys(obj).length).to.equal(0); // 객체의 길이를 나타내는 매서드

// 일반적인 길이를 나타내는 매서드는 .length인데, 객체에 length를 사용하게 되면 obj.length로 dot notation으로 인식하게 된다.
```

- 07_Array.js

```jsx
arr = [1, 2, 3]
const poppedValue = arr.pop();
expect(poppedValue).to.equal(3);

arr = [3, 1, 2]
const shiftedValue = arr.shift();
expect(shiftedValue).to.deep.equal(3);

// 각 변수에 담기는 값이 [1, 2]라고 생각하기 쉽다. 하지만 실제 담기는 값은 삭제되는 수의 값이다.
```
