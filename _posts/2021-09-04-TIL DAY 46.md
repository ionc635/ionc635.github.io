---
layout: single
title: TIL DAY 46
--- 
# Section2 2주차 복습, sudoku 문제 해결

## [오늘의 교훈]

- 학습 시간이 관리 되지 않는다는 것을 느끼고 있다. 현재 학습에 대한 뚜렷한 계획이 없다. 특정 시점에 필요한 부분을 학습하는 식으로 진행하고 있는데, 비효율적이라고 느낀다. 앞으로 시간을 쪼개서 어떤 학습을 할 것인지, 어떻게 학습할 것인지 분명하게 계획해야 한다. 이 또한 내 습관으로 만들어 갈 것이다.

## [오늘의 해결]

### sudoku 문제 정리

```jsx
 const aux = (idx, blanks, board) => {
    if (idx === blanks.length) {
      return true;
    }

    const [row, col] = blanks[idx]; 
    for (let num = 1; num <= 9; num++) { 
      if (isValid(row, col, num) === true) { 
        toggleNum(row, col, num);
        if (aux(idx + 1, blanks, board) === true) {
          return true;
        }
        toggleNum(row, col, num);
      }
    }
    return false;
  };
  aux(0, blanks, board);
  return board;
};
```

먼저, 0번째 인덱스의 row와 col에 들어갈 수를 for문으로 탐색한다. 1에서 9까지 수를 입력하는 도중 특정 수의 값이 isValid 함수에 의해서 true라고 판별되면 toggleNum 함수를 사용해 값을 넣어준다. 다음으로 aux 함수가 재귀로 실행이 되는데, 이때에는 다음 blanks의 1번째 인덱스의 값을 탐색한다. 마찬가지로 반복문으로 1에서 9까지 탐색을 하게 되는데, 특정 수의 값을 isVaild로 true인지 판별한다. 만약 모든 재귀에서 첫번째에 들어간 수가 알맞게 들어가 마지막까지 진행된다면 aux 함수의 첫번째에 정의한 조건문으로 true를 반환하게 된다. 이후에 모든 aux 재귀 함수가 true를 반환하면서 아래의 toggleNum과 return false; 함수는 실행되지 않고 최종 board 값을 출력한다.

하지만 특정 경우에 먼저 들어간 수로 인해 이후의 인덱스에서 isValid 함수가 실행되지 못한다면 문제가 복잡해진다. 조건문을 지나쳐 false 값을 반환하게 되고, 이전의 aux에서 아래의 toggleNum이 실행된다. 이미 들어간 수를  반환하는 것이다. 그리고 지금까지 진행된 반복문 이후부터 다시 진행하게 된다. 여기에서 조차 false를 리턴하게 되면 그 이전으로 돌아가 해당 로직을 반복하게 된다. 다시 돌아가 기존의 입력된 수가 아닌 새로운 수가 입력이 되면, 그 이후의 aux에서는 반복문을 처음부터 다시 시작한다. 아까와는 다른 새로운 함수가 시작된다고 보면 된다. 간단하게 말하면, isValid에서 true를 출력하면, 앞으로 이동. isValid에서 false를 출력하면 뒤로 이동하는 것이다. 

### 객체 지향 프로그래밍 복습

자바스크립트는 JAVA, C# 언어와 다르게 객체 지향 프로그래밍을 구현하기 위해 Class 문법을 사용한다. 프로그래밍에서는 반복되는 작업을 효율적으로 처리하는 것을 좋아한다. 만약 같은 속성과 매소드가 반복되는 함수를 여러개 만들어야 한다고 가정해보자. 물론 내부 요소가 약간의 차이는 있을 수 있을 것이다. 그렇다 하더라도 중복된 속성과 매소드가 있다면, 큰 틀의 함수를 만들고 이를 활용해 여러 비슷한 함수를 만드는 것이 효율적일 것이다. Class가 여기서 큰 틀을 의미하고, instance는 이 Class로 만든 객체를 의미한다. 그렇다면 일반 함수와 Class를 어떻게 구분하는지 궁금할 수도 있을 것이다. 보통 Class 명을 지을 때는 일반명사로 만들며, 첫 문자를 대문자로 지정한다. Class 안에는 속성과 매소드를 정의할 수 있다. 속성은 정적인 상태, 매소드는 동적인 상태라고 이해하면 쉽다. 예를 들면, 학생의 속성은 성적, 매소드는 공부라고 할 수 있다. 또한, 속성은 객체 형태이고, 매소드는 함수 형태이다. Class에 매소드를 정의하려면 Student.prototype.study 형식으로 작성해야 한다. 여기서 prototype을 쓰는 이유는 자바스크립트가 일급객체이고, 일반적으로 사용되는 매소드가 이 ptototype 객체 안에 속해있기 때문이다. instance를 만들 때, 속성 앞에는 보통 this.가 등장한다. 이 this에는 instance로 선언된 변수명이 입력된다. 배열도 Array의 instance로 new Array() 형식으로 사용할 수 있다.

객체 지향  프로그래밍에는 4가지 큰 특징이 있다. 캡슐화, 상속, 추상화, 다형성이다. 캡슐화는 데이터(속성)와 기능(매소드)을 단위로 느슨한게 묶어서 구현은 숨기고 동작은 노출 시키는 것이다. 추상화는 실제 노출되는 부분은 단순하게 만드는 개념이다. 고차함수를 보면 구현 세부사항은 노출되어 있지 않고 코드 복잡성을 줄일 수 있다. 캡슐화와 추상화는 비슷한 개념으로 보일 수 있다. 둘의 차이점은 추상화가 구현 세부 사항을 숨겨 코드 복잡성을 줄이는 반면 캡슐화는 기능 구현을 외부로 부터 숨겨 보호할 수 것이다. 상속은 부모 클래스의 특징을 자식 클래스가 물려 받는 특징이다. 만약 사람 클래스가 있다면, 새롭게 학생 클래스를 만드는 것은 비효율적일 것이다. 학생도 결국엔 사람이기 때문에 중복되는 속성을 상속 받고, 추가적으로 학생에게 필요한 속성과 매소드를 추가하는 것이 효율적이다. 마지막으로 다형성은 같은 매소드라고 하더라도 다른 방식으로 구현될 수 있는 것을 말한다. 

### 재귀 복습

- URCLASS 재귀 개념, 코플릿 재귀 문제 복습

## [오늘의 한줄]

- 당신을 다른 사람과 비교하지 말고, 오직 어제의 당신하고만 비교하라
