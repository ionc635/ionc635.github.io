# 2022-01-04-TIL DAY 128

### 프로젝트에서 ORM을 사용하셨나요? 사용하셨다면 Raw Query를 사용하지 않고 ORM을 활용한 이유에 대해 설명해주세요.

**ORM의 장점**

객체 지향적 코드로 인해 더 직관적이기 때문에 비즈니스 로직에 집중할 수 있도록 도와준다.

재사용 및 유지보수의 편리성이 증가한다.

DBMS에 대한 종속성이 줄어든다.

**ORM의 단점**

ORM만으로는 완벽한 구현이 어렵다.

프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기 어렵다.

**(*프로시저: 특정작업을 위한 프로그램의 일부. 함수와 같은 의미)**

### Node.js와 웹 브라우저의 차이점에 대해서 설명해주세요.

**공통점:** 둘 모두 자바스크립트 엔진(V8)을 내장하고 있어, 자바스크립트 언어를 기반으로 실행된다.

**차이점**

**존재 목적**

브라우저: 사용자에게 화면을 보여주는 것

Node.js: 서버 환경을 제공하는 것

**제공되는 API**

브라우저: 화면을 보여주는 것이 주 목적이기에 DOM에 접근하여 HTML을 조작하는 DOM API를 제공한다. DOM API를 사용하여 window, document 객체에 접근이 가능하다.

Node.js: 서버 환경 구축이 주 목적이기에 DOM에 접근을 하지 못하는 대신 파일, 시스템 관련 API를 제공한다.

**엔진**

브라우저: 대표적인 크롬에서는 v8 엔진을 사용하며, 브라우저 별로 엔진이 다르다.

Node.js: v8 엔진을 사용한다.

**모듈**

브라우저: ES 모듈 표준 (import 사용)

Node.js: CommonJS 모듈 시스템 (require 사용). Node.js v13.2 이상 부터는 ES 모듈을 지원한다.

### 데이터베이스에서 인덱스를 사용하는 이유

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸린다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다. 데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.

**장점**

- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

**단점**

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

### **데이터베이스 정규화 (Database Normalization)**

정규화(Normalization)의 기본 목표는 테이블 간에 중복된 데이터를 허용하지 않는다는 것이다. 중복된 데이터를 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다.

관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 **정규화(Normalization)**라고 한다.

- 데이터 중복(Data redundancy)
- 데이터 무결성(Data integrity)
- 데이터 이상 현상(Anomaly)

### 연결 리스트와 배열의 차이

**배열(Array)** -  배열은 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력하며, 물리적 주소 또한 순차적이다. 그리고 인덱스를 가지고 있어서 원하는 데이터를 한번에 접근이 가능하기 데이터 접근 속도가 매우 빠르다. 그러나 배열은 데이터의 삽입/삭제에는 취약하다. 배열 특성상 데이터 삽입/삭제가 이루어지면 삽입/삭제가 이루어진 위치의 다음부터 모든 데이터의 위치를 변경해야 하기 때문이다.

**연결리스트(LinkedList)** -  연결리스트는 데이터를 논리적 순서에 따라 데이터를 입력한다. 하지만 물리적 주소는 순차적이지 않다. 인덱스를 가지고 있는 배열과는 달리 연결리스트는 인덱스 대신 현재 위치의 이전 및 다음 위치를 기억하고 있다. 때문에 한번에 데이터 접근이 가능하지 않고 연결되어 있는 링크를 따라가야만 접근이 가능하고, 배열에 비해 속도가 떨어진다. 하지만 데이터 삽입/삭제는 논리적 주소만 바꿔주면 되기 때문에 데이터 삽입/삭제는 용이하다.

데이터 양이 많지만 데이터의 삽입/삭제가 거의 없고, 데이터 접근이 빈번하게 이루어질 경우는 배열이 유리하고, 데이터 양이 그렇게 많지 않고, 데이터의 삽입/삭제가 빈번하게 이루어질 경우에는 연결리스트가 유리하다